"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @license
 * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
const assert_1 = require("assert");
function _getTransitiveDependencies(url, entrypoints, analyzer) {
    return __awaiter(this, void 0, void 0, function* () {
        const document = yield analyzer.analyze(url);
        const imports = document.getByKind('import', { externalPackages: true, imported: true });
        const eagerImports = new Set();
        const lazyImports = new Set();
        for (const htmlImport of imports) {
            try {
                console.assert(htmlImport.url, 'htmlImport: %s has no url', htmlImport);
            }
            catch (err) {
                if (err instanceof assert_1.AssertionError) {
                    continue;
                }
                throw err;
            }
            switch (htmlImport.type) {
                case 'html-import':
                    eagerImports.add(htmlImport.document.url);
                    break;
                case 'lazy-html-import':
                    lazyImports.add(htmlImport.document.url);
                    break;
            }
        }
        return { url: url, eager: eagerImports, lazy: lazyImports };
    });
}
function buildDepsIndex(entrypoints, analyzer) {
    return __awaiter(this, void 0, void 0, function* () {
        const entrypointToDependencies = new Map();
        const dependenciesToEntrypoints = new Map();
        const queue = Array.from(entrypoints);
        const visitedEntrypoints = new Set();
        while (queue.length > 0) {
            const entrypoint = queue.shift();
            if (visitedEntrypoints.has(entrypoint)) {
                continue;
            }
            const dependencyEntry = yield _getTransitiveDependencies(entrypoint, entrypoints, analyzer);
            const dependencies = new Set(dependencyEntry.eager);
            dependencies.add(entrypoint);
            entrypointToDependencies.set(entrypoint, dependencies);
            for (const lazyDependency of dependencyEntry.lazy.values()) {
                if (!visitedEntrypoints.has(lazyDependency)) {
                    queue.push(lazyDependency);
                }
            }
        }
        entrypointToDependencies.forEach((dependencies, entrypoint, map) => {
            for (const dependency of dependencies) {
                if (!dependenciesToEntrypoints.has(dependency)) {
                    dependenciesToEntrypoints.set(dependency, new Set());
                }
                const entrypointSet = dependenciesToEntrypoints.get(dependency);
                entrypointSet.add(entrypoint);
            }
        });
        return { entrypointToDeps: entrypointToDependencies };
    });
}
exports.buildDepsIndex = buildDepsIndex;
//# sourceMappingURL=deps-index.js.map