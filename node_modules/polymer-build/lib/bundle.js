/**
 * @license
 * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const File = require("vinyl");
const parse5 = require("parse5");
const polymer_analyzer_1 = require("polymer-analyzer");
const polymer_bundler_1 = require("polymer-bundler");
const bundle_manifest_1 = require("polymer-bundler/lib/bundle-manifest");
const stream_1 = require("stream");
const file_map_url_loader_1 = require("./file-map-url-loader");
const path_transformers_1 = require("./path-transformers");
class BuildBundler extends stream_1.Transform {
    constructor(config, buildAnalyzer) {
        super({ objectMode: true });
        this.files = new Map();
        this.config = config;
        this._buildAnalyzer = buildAnalyzer;
        this._bundler = new polymer_bundler_1.Bundler({
            // TODO(usergenic): Creating a new Analyzer with a blank cache is going
            // to mean, at least, a doubling of analysis efforts for bundling phase.
            // Ideally we would fork existing analyzer and replace its urlLoader if
            // there were an affordance to do so.
            analyzer: new polymer_analyzer_1.Analyzer({ urlLoader: new file_map_url_loader_1.FileMapUrlLoader(this.config.root, this.files) }),
            inlineCss: true,
            inlineScripts: true,
        });
    }
    _transform(file, _encoding, callback) {
        this.files.set(path_transformers_1.urlFromPath(this.config.root, file.path), file);
        callback(null, file);
    }
    _flush(done) {
        return __awaiter(this, void 0, void 0, function* () {
            const bundles = yield this._buildBundles();
            for (const filename of bundles.keys()) {
                const filepath = path_transformers_1.pathFromUrl(this.config.root, filename);
                this.push(new File({
                    path: filepath,
                    contents: new Buffer(bundles.get(filename)),
                }));
            }
            // end the stream
            done();
        });
    }
    _buildBundles() {
        return __awaiter(this, void 0, void 0, function* () {
            let strategy;
            if (this.config.shell) {
                strategy = bundle_manifest_1.generateShellMergeStrategy(path_transformers_1.urlFromPath(this.config.root, this.config.shell));
            }
            const bundleEntrypoints = Array.from(this.config.allFragments);
            const docCollection = yield this._bundler.bundle(bundleEntrypoints.map(f => path_transformers_1.urlFromPath(this.config.root, f)), strategy);
            const contentsMap = new Map();
            for (const bundleName of docCollection.keys()) {
                contentsMap.set(bundleName, parse5.serialize(docCollection.get(bundleName).ast));
            }
            return contentsMap;
        });
    }
}
exports.BuildBundler = BuildBundler;
