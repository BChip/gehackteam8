'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.importer = importer;

var _dependencies = require('./dependencies');

var _dependencies2 = _interopRequireDefault(_dependencies);

var _diagnostics = require('diagnostics');

var _diagnostics2 = _interopRequireDefault(_diagnostics);

var _resolve = require('resolve');

var _resolve2 = _interopRequireDefault(_resolve);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var mock = _path2.default.join(__dirname, '..', 'circular.scss');
var debug = (0, _diagnostics2.default)('sass-import-modules');

/**
 * Append extension to file if required.
 *
 * @param {String} file File path.
 * @param {String} ext File extension.
 * @returns {String} file.
 * @api private
 */
function extension(file, ext) {
  if (! ~file.indexOf(ext)) {
    file += ext;
  }

  return file;
}

/**
 * Return the file path to node-sass.
 *
 * @param {String} file Absolute path to file.
 * @param {Function} done Completion callback.
 * @returns {void}
 * @api private
 */
function provide(file, done) {
  return void done({ file: file });
}

/**
 * Check if the file exists.
 *
 * @param {String} file
 * @param {Function} done Completion callback
 * @returns {void}
 * @api private
 */
function exists(file, done) {
  return void _fs2.default.stat(file, function (error, stat) {
    done(!error && !!stat);
  });
}

/**
 * Resolve the file in node_modules.
 *
 * @param {String} base Current directory.
 * @param {String} file File path.
 * @param {String} ext File extension.
 * @param {Function} next Completion callback.
 * @returns {void}
 * @api private
 */
function node(base, file, ext, next) {
  debug('Resolving file from node_modules: %s', file);

  return void (0, _resolve2.default)(extension(file, ext), { basedir: base }, function (error, result) {
    if (result) {
      return next(null, result);
    }

    (0, _resolve2.default)(file, { basedir: base }, next);
  });
}

/**
 * Resolve the file locally.
 *
 * @param {String} file File path.
 * @param {String} base Current directory.
 * @param {String} ext File extension.
 * @param {Function} next Completion callback.
 * @returns {void}
 * @api private
 */
function local(base, file, ext, next) {
  debug('Resolving file locally: %s', file);
  file = extension(_path2.default.join(base, file), ext);

  return void exists(file, function (exist) {
    next(null, exist ? file : null);
  });
}

/**
 * Resolve the file as partial by prepending an underscore.
 *
 * @param {String} file File path.
 * @param {String} base Current directory.
 * @param {String} ext File extension.
 * @param {Function} next Completion callback.
 * @returns {void}
 * @api private
 */
function partial(base, file, ext, next) {
  debug('Resolving file as partial with prepended underscore: %s', file);
  file = _path2.default.join(_path2.default.dirname(file), '_' + _path2.default.basename(file));

  return void local(base, file, ext, next);
}

/**
 * Generate a set of resolvers for each include path. Depending on the order
 * and provided resolvers, resolvers will resolve the file:
 *
 *  - relative to the previous file.
 *  - from a module in node_modules.
 *  - as partial with prepended underscore relative to the previous file.
 *
 * @param {Array} String references to resolvers.
 * @returns {Array} Resolve methods.
 * @api private
 */
function getResolvers(resolvers) {
  var resolverSet = { local: local, node: node, partial: partial };

  return resolvers.map(function (name) {
    return {
      name: name,
      fn: resolverSet[name]
    };
  }).filter(function (resolver) {
    return resolver.fn;
  });
}

/**
 * Setup an importer for node-sass.
 *
 * @param {Object} options Optional configuration.
 * @returns {Function} Importer.
 * @api public
 */
function importer() {
  var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

  var _ref$paths = _ref.paths;
  var paths = _ref$paths === undefined ? process.cwd() : _ref$paths;
  var _ref$ext = _ref.ext;
  var ext = _ref$ext === undefined ? '.scss' : _ref$ext;
  var _ref$resolvers = _ref.resolvers;
  var resolvers = _ref$resolvers === undefined ? ['local', 'node'] : _ref$resolvers;

  var dependencies = new _dependencies2.default();
  resolvers = getResolvers(resolvers);

  if (ext.charAt(0) !== '.') {
    ext = '.' + ext;
  }

  /**
   * Importer for SASS.
   *
   * @param {String} url File to resolve.
   * @param {String} prev Last resolved file.
   * @param {Function} done Completion callback.
   * @returns {void} Return early.
   * @api private
   */
  return function resolve(url, prev, done) {
    var _ref2 = this.options || {};

    var includePaths = _ref2.includePaths;

    var dirnamePrev = _path2.default.dirname(prev);
    var includes = [].concat(includePaths || [], dirnamePrev, paths);
    var fns = resolvers.reduce(function (arr, resolver) {
      return arr.concat(includes.map(function (base) {
        return Object.assign({ base: base }, resolver);
      }));
    }, []);

    debug('Resolving: %s', url);
    (function run(stack, error) {
      var resolver = stack.shift();

      /**
       * Completion callback.
       *
       * @param {Error} err Error returned from resolver.
       * @param {String} file Full path to file.
       * @returns {Void} return early.
       * @api private
       */
      function next(err, file) {
        error = error || err;

        //
        // Mock with empty file if a circular dependency is detected.
        //
        if (dependencies.circular(prev, file)) {
          debug('Found circular dependency, mocking empty file');
          return void provide(mock, done);
        }

        //
        // Resolved to a file on disk, return the file early.
        //
        if (file) {
          dependencies.add(prev, file);
          return void provide(file, done);
        }

        //
        // All resolvers ran, no results found, return error if any.
        //
        if (!stack.length) {
          if (error) throw new Error('Could not find file: ' + url + ' from parent ' + prev);
          return void done();
        }

        //
        // Iterate over the stack.
        //
        debug('Stack step complete, iterating over remaining %d', stack.length);
        return void run(stack, err, next);
      }

      debug('Lookup %s [%s,  %s]', url, resolver.name, resolver.base);
      resolver.fn(resolver.base, url, ext, next);
    })(fns);
  };
};