/**
 * @license
 * Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const model_1 = require("../model/model");
const js_utils_1 = require("./js-utils");
const polymer_element_mixin_1 = require("./polymer-element-mixin");
class LocalId {
    constructor(name, range) {
        this.name = name;
        this.range = range;
    }
}
exports.LocalId = LocalId;
function addProperty(target, prop) {
    target.properties.push(prop);
    const attributeName = propertyToAttributeName(prop.name);
    // Don't produce attributes or events for nonpublic properties, properties
    // that aren't in Polymer's `properties` block (i.e. not published),
    // or properties whose names can't be converted into attribute names.
    if ((prop.privacy && prop.privacy !== 'public') || !attributeName ||
        !prop.published) {
        return;
    }
    target.attributes.push({
        name: attributeName,
        sourceRange: prop.sourceRange,
        description: prop.description,
        type: prop.type,
        changeEvent: prop.notify ? `${attributeName}-changed` : undefined
    });
    if (prop.notify) {
        target.events.push({
            name: `${attributeName}-changed`,
            description: `Fired when the \`${prop.name}\` property changes.`,
            sourceRange: prop.sourceRange,
            astNode: prop.astNode,
            warnings: []
        });
    }
}
exports.addProperty = addProperty;
function addMethod(target, method) {
    target.methods.push(method);
}
exports.addMethod = addMethod;
/**
 * The metadata for a single polymer element
 */
class ScannedPolymerElement extends model_1.ScannedElement {
    constructor(options) {
        super();
        this.properties = [];
        this.methods = [];
        this.observers = [];
        this.listeners = [];
        this.behaviorAssignments = [];
        // Indicates if an element is a pseudo element
        this.pseudo = false;
        // TODO(justinfagnani): fix this constructor to not be crazy, or remove
        // class altogether.
        const optionsCopy = Object.assign({}, options);
        delete optionsCopy.properties;
        delete optionsCopy.methods;
        Object.assign(this, optionsCopy);
        if (options && options.properties) {
            options.properties.forEach((p) => this.addProperty(p));
        }
        if (options && options.methods) {
            options.methods.forEach((m) => this.addMethod(m));
        }
    }
    addProperty(prop) {
        addProperty(this, prop);
    }
    addMethod(method) {
        addMethod(this, method);
    }
    resolve(document) {
        return resolveElement(this, document);
    }
}
exports.ScannedPolymerElement = ScannedPolymerElement;
class PolymerElement extends model_1.Element {
    constructor() {
        super();
        this.properties = [];
        this.methods = [];
        this.observers = [];
        this.listeners = [];
        this.behaviorAssignments = [];
        this.localIds = [];
        this.kinds = new Set(['element', 'polymer-element']);
    }
    emitPropertyMetadata(property) {
        const polymerMetadata = {};
        const polymerMetadataFields = ['notify', 'observer', 'readOnly'];
        for (const field of polymerMetadataFields) {
            if (field in property) {
                polymerMetadata[field] = property[field];
            }
        }
        return { polymer: polymerMetadata };
    }
}
exports.PolymerElement = PolymerElement;
/**
 * Implements Polymer core's translation of property names to attribute names.
 *
 * Returns null if the property name cannot be so converted.
 */
function propertyToAttributeName(propertyName) {
    // Polymer core will not map a property name that starts with an uppercase
    // character onto an attribute.
    if (propertyName[0].toUpperCase() === propertyName[0]) {
        return null;
    }
    return propertyName.replace(/([A-Z])/g, (_, c1) => `-${c1.toLowerCase()}`);
}
function resolveElement(scannedElement, document) {
    const element = new PolymerElement();
    element.privacy = scannedElement.privacy;
    applySuperClass(element, scannedElement, document);
    applyMixins(element, scannedElement, document);
    applySelf(element, scannedElement, document);
    //
    // Behaviors
    //
    // TODO(justinfagnani): Refactor behaviors to work like superclasses and
    // mixins and be applied before own members
    const behaviorsAndWarnings = getBehaviors(scannedElement.behaviorAssignments, document);
    // This has the combined effects of copying the array of warnings from the
    // ScannedElement, and adding in any new ones found when resolving behaviors.
    element.warnings = element.warnings.concat(behaviorsAndWarnings.warnings);
    const behaviors = Array.from(behaviorsAndWarnings.behaviors);
    element.properties = inheritValues(element.properties, behaviors.map((b) => ({ source: b.className, values: b.properties })));
    element.methods = inheritValues(element.methods, behaviors.map((b) => ({ source: b.className, values: b.methods })));
    element.attributes = inheritValues(element.attributes, behaviors.map((b) => ({ source: b.className, values: b.attributes })));
    element.events = inheritValues(element.events, behaviors.map((b) => ({ source: b.className, values: b.events })));
    const domModule = document.getOnlyAtId('dom-module', scannedElement.tagName || '', { imported: true, externalPackages: true });
    if (domModule) {
        element.description = element.description || domModule.comment || '';
        element.domModule = domModule.node;
        element.slots = domModule.slots.slice();
        element.localIds = domModule.localIds.slice();
    }
    if (scannedElement.pseudo) {
        element.kinds.add('pseudo-element');
    }
    for (const method of element.methods) {
        // methods are only public by default if they're documented.
        method.privacy = js_utils_1.getOrInferPrivacy(method.name, method.jsdoc, true);
    }
    return element;
}
/**
 * Note: mutates `element`.
 */
function inheritFrom(element, superElement) {
    // TODO(justinfagnani): fixup and use inheritValues, but it has slightly odd
    // semantics currently
    for (const superProperty of superElement.properties) {
        const newProperty = Object.assign({}, superProperty);
        if (!newProperty.inheritedFrom) {
            const superName = getSuperName(superElement);
            if (superName) {
                newProperty.inheritedFrom = superName;
            }
        }
        element.properties.push(newProperty);
    }
    for (const superMethod of superElement.methods) {
        const newMethod = Object.assign({}, superMethod);
        if (!newMethod.inheritedFrom) {
            const superName = getSuperName(superElement);
            if (superName) {
                newMethod.inheritedFrom = superName;
            }
        }
        element.methods.push(newMethod);
    }
    for (const superAttribute of superElement.attributes) {
        const newAttribute = Object.assign({}, superAttribute);
        if (!newAttribute.inheritedFrom) {
            const superName = getSuperName(superElement);
            if (superName) {
                newAttribute.inheritedFrom = superName;
            }
        }
        element.attributes.push(newAttribute);
    }
    for (const superEvent of superElement.events) {
        const newEvent = Object.assign({}, superEvent);
        if (!newEvent.inheritedFrom) {
            const superName = getSuperName(superElement);
            if (superName) {
                newEvent.inheritedFrom = superName;
            }
        }
        element.events.push(newEvent);
    }
    // TODO(justinfagnani): slots, listeners, observers, dom-module?
    // What actually inherits?
}
function applySelf(element, scannedElement, document) {
    // TODO(justinfagnani): Copy over all properties better, or have
    // PolymerElement wrap ScannedPolymerElement.
    element.abstract = scannedElement.abstract;
    element.astNode = scannedElement.astNode;
    scannedElement.attributes.forEach((o) => element.attributes.push(o));
    scannedElement.behaviorAssignments.forEach((o) => element.behaviorAssignments.push(o));
    element.className = scannedElement.className;
    scannedElement.demos.forEach((o) => element.demos.push(o));
    element.description = scannedElement.description;
    element.domModule = scannedElement.domModule;
    scannedElement.events.forEach((o) => element.events.push(o));
    element.extends = scannedElement.extends;
    element.jsdoc = scannedElement.jsdoc;
    scannedElement.listeners.forEach((o) => element.listeners.push(o));
    // scannedElement.mixins.forEach(
    //     (o) => element.mixins.push(o.resolve(document)));
    scannedElement.observers.forEach((o) => element.observers.push(o));
    scannedElement.properties.forEach((o) => element.properties.push(o));
    scannedElement.methods.forEach((o) => element.methods.push(o));
    element.scriptElement = scannedElement.scriptElement;
    scannedElement.slots.forEach((o) => element.slots.push(o));
    element.sourceRange = scannedElement.sourceRange;
    element.summary = scannedElement.summary;
    element.superClass =
        scannedElement.superClass && scannedElement.superClass.resolve(document);
    element.tagName = scannedElement.tagName;
    scannedElement.warnings.forEach((o) => element.warnings.push(o));
}
function applySuperClass(element, scannedElement, document) {
    if (scannedElement.superClass &&
        scannedElement.superClass.identifier !== 'HTMLElement') {
        const superElements = document.getById('element', scannedElement.superClass.identifier, {
            externalPackages: true,
            imported: true,
        });
        if (superElements.size === 1) {
            const superElement = superElements.values().next().value;
            if (!superElement.kinds.has('polymer-element')) {
                element.warnings.push({
                    message: `A Polymer element can\'t extend from a non-Polymer element: ${scannedElement
                        .superClass.identifier}`,
                    severity: model_1.Severity.ERROR,
                    code: 'unknown-superclass',
                    sourceRange: scannedElement.superClass.sourceRange,
                });
            }
            else {
                inheritFrom(element, superElement);
            }
        }
        else {
            if (superElements.size === 0) {
                element.warnings.push({
                    message: `Unable to resolve superclass ${scannedElement.superClass
                        .identifier}`,
                    severity: model_1.Severity.ERROR,
                    code: 'unknown-superclass',
                    sourceRange: scannedElement.superClass.sourceRange,
                });
            }
            else {
                element.warnings.push({
                    message: `Multiple superclasses found for ${scannedElement.superClass
                        .identifier}`,
                    severity: model_1.Severity.ERROR,
                    code: 'unknown-superclass',
                    sourceRange: scannedElement.superClass.sourceRange,
                });
            }
        }
    }
}
function applyMixins(element, scannedElement, document) {
    for (const scannedMixinReference of scannedElement.mixins) {
        const mixinReference = scannedMixinReference.resolve(document);
        const mixinId = mixinReference.identifier;
        element.mixins.push(mixinReference);
        const mixins = document.getById('element-mixin', mixinId, {
            externalPackages: true,
            imported: true,
        });
        if (mixins.size === 0) {
            element.warnings.push({
                message: `@mixes reference not found: ${mixinId}.` +
                    `Did you import it? Is it annotated with @polymerMixin?`,
                severity: model_1.Severity.ERROR,
                code: 'mixes-reference-not-found',
                sourceRange: scannedMixinReference.sourceRange,
            });
            continue;
        }
        else if (mixins.size > 1) {
            element.warnings.push({
                message: `@mixes reference, multiple mixins found ${mixinId}`,
                severity: model_1.Severity.ERROR,
                code: 'mixes-reference-multiple-found',
                sourceRange: scannedMixinReference.sourceRange,
            });
            continue;
        }
        const mixin = mixins.values().next().value;
        if (!(mixin instanceof polymer_element_mixin_1.PolymerElementMixin)) {
            element.warnings.push({
                message: `@mixes reference to a non-Mixin ${mixinId}`,
                severity: model_1.Severity.ERROR,
                code: 'mixes-reference-non-mixin',
                sourceRange: scannedMixinReference.sourceRange,
            });
            continue;
        }
        inheritFrom(element, mixin);
    }
}
// TODO(justinfagnani): move to Behavior
function getBehaviors(behaviorAssignments, document) {
    const resolvedBehaviors = new Set();
    const warnings = _getFlattenedAndResolvedBehaviors(behaviorAssignments, document, resolvedBehaviors);
    return { behaviors: resolvedBehaviors, warnings };
}
exports.getBehaviors = getBehaviors;
function _getFlattenedAndResolvedBehaviors(behaviorAssignments, document, resolvedBehaviors) {
    const warnings = [];
    for (const behavior of behaviorAssignments) {
        const foundBehaviors = document.getById('behavior', behavior.name, { imported: true, externalPackages: true });
        if (foundBehaviors.size === 0) {
            warnings.push({
                message: `Unable to resolve behavior ` +
                    `\`${behavior.name}\`. Did you import it? Is it annotated with ` +
                    `@polymerBehavior?`,
                severity: model_1.Severity.ERROR,
                code: 'unknown-polymer-behavior',
                sourceRange: behavior.sourceRange
            });
            // Skip processing this behavior.
            continue;
        }
        if (foundBehaviors.size > 1) {
            warnings.push({
                message: `Found more than one behavior named ${behavior.name}.`,
                severity: model_1.Severity.WARNING,
                code: 'multiple-polymer-behaviors',
                sourceRange: behavior.sourceRange
            });
            // Don't skip processing this behavior, just take the most recently
            // declared instance.
        }
        const foundBehavior = Array.from(foundBehaviors)[foundBehaviors.size - 1];
        if (resolvedBehaviors.has(foundBehavior)) {
            continue;
        }
        resolvedBehaviors.add(foundBehavior);
        // Note that we don't care about warnings from transitively resolved
        // behaviors. Those should become warnings on those behaviors themselves.
        _getFlattenedAndResolvedBehaviors(foundBehavior.behaviorAssignments, document, resolvedBehaviors);
    }
    return warnings;
}
/**
 * Merges values from `newValuesBySource` into `values`, but only if they
 * don't already exist in `values`, thus giving an inheritance-like behavior.
 *
 * TODO(justinfagnani): we should always build up an element from base-class
 * on up to get natural overriding behavior. We should also merges
 * individual definitions if that's what Polymer does. Need tests.
 */
function inheritValues(values, newValuesBySource) {
    const valuesByName = new Map();
    for (const initial of values) {
        valuesByName.set(initial.name, initial);
    }
    for (const source of newValuesBySource) {
        for (const value of source.values) {
            if (!valuesByName.has(value.name)) {
                const copy = Object.assign({}, value);
                // If a value is already inherited, prefer the original source
                copy.inheritedFrom = value.inheritedFrom || source.source;
                valuesByName.set(copy.name, copy);
            }
        }
    }
    return Array.from(valuesByName.values());
}
function getSuperName(superElement) {
    // TODO(justinfagnani): Mixins, elements and functions should all have a
    // name property.
    if (superElement instanceof PolymerElement) {
        return superElement.className;
    }
    else if (superElement instanceof polymer_element_mixin_1.PolymerElementMixin) {
        return superElement.name;
    }
}

//# sourceMappingURL=polymer-element.js.map
