{"version":3,"sources":["polymer/polymer2-element-scanner.ts"],"names":[],"mappings":"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","file":"polymer2-element-scanner.js","sourcesContent":["/**\n * @license\n * Copyright (c) 2015 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport * as estree from 'estree';\n\nimport * as astValue from '../javascript/ast-value';\nimport {getIdentifierName, getNamespacedIdentifier} from '../javascript/ast-value';\nimport {Visitor} from '../javascript/estree-visitor';\nimport * as esutil from '../javascript/esutil';\nimport {JavaScriptDocument} from '../javascript/javascript-document';\nimport {JavaScriptScanner} from '../javascript/javascript-scanner';\nimport * as jsdoc from '../javascript/jsdoc';\nimport {ScannedElement, ScannedFeature, ScannedReference, Severity, SourceRange, Warning} from '../model/model';\n\nimport {extractObservers} from './declaration-property-handlers';\nimport {getOrInferPrivacy} from './js-utils';\nimport {Observer, ScannedPolymerElement} from './polymer-element';\nimport {getIsValue, getMethods, getProperties} from './polymer2-config';\n\n\n/** Represents the value of an operation that may fail. */\ntype Result<V, E> = {\n  successful: true; value: V;\n}|{\n  successful: false;\n  value: E;\n};\n\n/**\n * Represents the first argument of a call to customElements.define.\n */\ntype TagNameExpression = ClassDotIsExpression|StringLiteralExpression;\n\n/** The tagname was the `is` property on an class, like `MyElem.is` */\ninterface ClassDotIsExpression {\n  type: 'is';\n  className: string;\n  classNameSourceRange: SourceRange;\n}\n/** The tag name was just a string literal. */\ninterface StringLiteralExpression {\n  type: 'string-literal';\n  value: string;\n  sourceRange: SourceRange;\n}\n\n\nexport interface ScannedAttribute extends ScannedFeature {\n  name: string;\n  type?: string;\n}\n\nexport class Polymer2ElementScanner implements JavaScriptScanner {\n  async scan(\n      document: JavaScriptDocument,\n      visit: (visitor: Visitor) => Promise<void>): Promise<ScannedElement[]> {\n    const visitor = new ElementVisitor(document);\n    await visit(visitor);\n    return visitor.getRegisteredElements();\n  }\n}\n\nclass ElementVisitor implements Visitor {\n  private _possibleElements = new Map<string, ScannedElement>();\n  private _registeredButNotFound = new Map<string, TagNameExpression>();\n  private _elements: Set<ScannedElement> = new Set();\n  private _document: JavaScriptDocument;\n  // TODO(rictic): write a WarningFeature. Emit them from this scanner.\n  private _warnings: Warning[] = [];\n\n  private _currentElement: ScannedPolymerElement|null = null;\n  private _currentElementNode: estree.Node|null = null;\n\n  constructor(document: JavaScriptDocument) {\n    this._document = document;\n  }\n\n  enterClassExpression(node: estree.ClassExpression, parent: estree.Node) {\n    if (parent.type !== 'AssignmentExpression' &&\n        parent.type !== 'VariableDeclarator') {\n      return;\n    }\n    const className = astValue.getIdentifierName(\n        parent.type === 'AssignmentExpression' ? parent.left : parent.id);\n    if (className == null) {\n      return;\n    }\n    const element = this._handleClass(node);\n    if (element) {\n      const nodeComments = esutil.getAttachedComment(node) || '';\n      const nodeJsDocs = jsdoc.parseJsdoc(nodeComments);\n      const namespacedClassName =\n          getNamespacedIdentifier(className, nodeJsDocs);\n      element.className = namespacedClassName;\n\n      const summaryTag = jsdoc.getTag(nodeJsDocs, 'summary');\n      element.summary = (summaryTag && summaryTag.description) || '';\n\n      // Set the element on both the namespaced & unnamespaced names so that we\n      // can detect registration by either name.\n      this._possibleElements.set(namespacedClassName, element);\n      this._possibleElements.set(className, element);\n    }\n  }\n\n  enterClassDeclaration(node: estree.ClassDeclaration) {\n    const element = this._handleClass(node);\n    if (element) {\n      const className = node.id.name;\n      const nodeComments = esutil.getAttachedComment(node) || '';\n      const nodeJsDocs = jsdoc.parseJsdoc(nodeComments);\n      const namespacedClassName =\n          getNamespacedIdentifier(className, nodeJsDocs);\n      element.className = namespacedClassName;\n\n      const summaryTag = jsdoc.getTag(nodeJsDocs, 'summary');\n      element.summary = (summaryTag && summaryTag.description) || '';\n\n      // Set the element on both the namespaced & unnamespaced names so that we\n      // can detect registration by either name.\n      this._possibleElements.set(className, element);\n      this._possibleElements.set(namespacedClassName, element);\n    }\n  }\n\n  enterVariableDeclaration(\n      node: estree.VariableDeclaration, _parent: estree.Node) {\n    // This is for cases when a class is defined by only applying a mixin\n    // to a superclass, like: const Elem = Mixin(HTMLElement);\n    // In this case we don't have a ClassDeclaration or ClassExpresion\n    // to traverse into.\n\n    // TODO(justinfagnani): factor out more common code for creating\n    // an element from jsdocs.\n\n    const comment = esutil.getAttachedComment(node) || '';\n    const docs = jsdoc.parseJsdoc(comment);\n    const isElement = this._hasPolymerDocTag(docs);\n    const sourceRange = this._document.sourceRangeForNode(node);\n    if (isElement) {\n      const warnings: Warning[] = [];\n      const _extends = this._getExtends(node, docs, warnings);\n      const mixins = jsdoc.getMixins(this._document, node, docs, warnings);\n\n      // The name of the variable is available in a child VariableDeclarator\n      // so we save the element and node representing the element to access\n      // in enterVariableDeclarator\n      this._currentElementNode = node;\n\n      const className = astValue.getIdentifierName(node) || '';\n      const namespacedClassName = getNamespacedIdentifier(className, docs);\n\n      const element = this._currentElement = new ScannedPolymerElement({\n        astNode: node,\n        sourceRange,\n        description: docs.description,\n        superClass: _extends,  //\n        mixins,\n        className: namespacedClassName,\n        privacy: getOrInferPrivacy(namespacedClassName, docs, false)\n      });\n      this._elements.add(this._currentElement);\n\n\n      const summaryTag = jsdoc.getTag(docs, 'summary');\n      element.summary = (summaryTag && summaryTag.description) || '';\n\n      // Set the element on both the namespaced & unnamespaced names so that we\n      // can detect registration by either name.\n      this._possibleElements.set(namespacedClassName, element);\n      if (className) {\n        this._possibleElements.set(className, element);\n      }\n    }\n  }\n\n  leaveVariableDeclaration(\n      node: estree.VariableDeclaration, _parent: estree.Node) {\n    if (this._currentElementNode === node) {\n      // Clean up state when we leave a declaration that defined an element.\n      this._currentElement = null;\n      this._currentElementNode = null;\n    }\n  }\n\n  enterVariableDeclarator(\n      node: estree.VariableDeclarator, parent: estree.Node) {\n    if (this._currentElement != null && parent === this._currentElementNode) {\n      const name = (node.id as estree.Identifier).name;\n      const parentComments = esutil.getAttachedComment(parent) || '';\n      const parentJsDocs = jsdoc.parseJsdoc(parentComments);\n      this._currentElement.className =\n          getNamespacedIdentifier(name, parentJsDocs);\n    }\n  }\n\n  /**\n   * Returns the name of the superclass, if any.\n   */\n  private _getExtends(\n      node: estree.ClassDeclaration|estree.ClassExpression|\n      estree.VariableDeclaration,\n      docs: jsdoc.Annotation, warnings: Warning[]): ScannedReference|undefined {\n    const extendsAnnotations =\n        docs.tags!.filter((tag) => tag.tag === 'extends');\n\n    // prefer @extends annotations over extends clauses\n    if (extendsAnnotations.length > 0) {\n      const extendsId = extendsAnnotations[0].name;\n      // TODO(justinfagnani): we need source ranges for jsdoc annotations\n      const sourceRange = this._document.sourceRangeForNode(node)!;\n      if (extendsId == null) {\n        warnings.push({\n          code: 'class-extends-annotation-no-id',\n          message: '@extends annotation with no identifier',\n          severity: Severity.WARNING, sourceRange,\n        });\n      } else {\n        return new ScannedReference(extendsId, sourceRange);\n      }\n    } else if (\n        node.type === 'ClassDeclaration' || node.type === 'ClassExpression') {\n      // If no @extends tag, look for a superclass.\n      // TODO(justinfagnani): Infer mixin applications and superclass from AST.\n      const superClass = node.superClass;\n      if (superClass != null) {\n        const extendsId = getIdentifierName(superClass);\n        if (extendsId != null) {\n          const sourceRange = this._document.sourceRangeForNode(superClass)!;\n          return new ScannedReference(extendsId, sourceRange);\n        }\n      }\n    }\n  }\n\n\n  private _handleClass(node: estree.ClassDeclaration|estree.ClassExpression) {\n    const comment = esutil.getAttachedComment(node) || '';\n    const docs = jsdoc.parseJsdoc(comment);\n    const isValue = getIsValue(node);\n    let warnings: Warning[] = [];\n\n    const observersResult = this._getObservers(node);\n    let observers: Observer[] = [];\n    if (observersResult) {\n      observers = observersResult.observers;\n      warnings = warnings.concat(observersResult.warnings);\n    }\n\n    const className = node.id && node.id.name;\n    const element = new ScannedPolymerElement({\n      className,\n      astNode: node,\n      tagName: isValue,\n      description: (docs.description || '').trim(),\n      events: esutil.getEventComments(node),\n      sourceRange: this._document.sourceRangeForNode(node),\n      properties: getProperties(node, this._document),\n      methods: getMethods(node, this._document),\n      superClass: this._getExtends(node, docs, warnings),\n      mixins: jsdoc.getMixins(this._document, node, docs, warnings),\n      privacy: getOrInferPrivacy(className || '', docs, false),  //\n      observers,\n    });\n\n    // If a class defines observedAttributes, it overrides what the base\n    // classes defined.\n    // TODO(justinfagnani): define and handle composition patterns.\n    const observedAttributes = this._getObservedAttributes(node);\n\n    if (observedAttributes != null) {\n      element.attributes = observedAttributes;\n    }\n\n    warnings.forEach((w) => element.warnings.push(w));\n\n    if (this._hasPolymerDocTag(docs)) {\n      this._elements.add(element);\n    }\n    return element;\n  }\n\n  enterCallExpression(node: estree.CallExpression) {\n    const callee = astValue.getIdentifierName(node.callee);\n    if (!(callee === 'window.customElements.define' ||\n          callee === 'customElements.define')) {\n      return;\n    }\n\n    const tagNameExpressionResult =\n        node.arguments[0] && this.getTagNameExpression(node.arguments[0]);\n    if (!tagNameExpressionResult.successful) {\n      this._warnings.push(tagNameExpressionResult.value);\n      return;\n    }\n    const tagNameExpression = tagNameExpressionResult.value;\n    if (tagNameExpression == null) {\n      return;\n    }\n    const elementDefn = node.arguments[1];\n    if (elementDefn == null) {\n      return;\n    }\n    const element: ScannedElement|null =\n        this._getElement(tagNameExpression, elementDefn);\n    if (!element) {\n      return;\n    }\n    this._elements.add(element);\n    const tagNameResult = this.getTagNameFromExpression(tagNameExpression);\n    if (tagNameResult.successful) {\n      element.tagName = tagNameResult.value;\n    } else {\n      this._warnings.push(tagNameResult.value);\n    }\n  }\n\n  private _getElement(tagName: TagNameExpression, elementDefn: estree.Node):\n      ScannedElement|null {\n    const className = astValue.getIdentifierName(elementDefn);\n    if (className) {\n      const element = this._possibleElements.get(className);\n      if (element) {\n        this._possibleElements.delete(className);\n        return element;\n      } else {\n        this._registeredButNotFound.set(className, tagName);\n        return null;\n      }\n    }\n    if (elementDefn.type === 'ClassExpression') {\n      return this._handleClass(elementDefn);\n    }\n    return null;\n  }\n\n  private _hasPolymerDocTag(docs: jsdoc.Annotation) {\n    const tags = docs.tags || [];\n    const elementTags =\n        tags.filter((t: jsdoc.Tag) => t.tag === 'polymerElement');\n    return elementTags.length >= 1;\n  }\n\n  private _getObservedAttributes(node: estree.ClassDeclaration|\n                                 estree.ClassExpression) {\n    const returnedValue =\n        this._getReturnValueOfStaticGetter(node, 'observedAttributes');\n    if (returnedValue && returnedValue.type === 'ArrayExpression') {\n      return this._extractAttributesFromObservedAttributes(returnedValue);\n    }\n  }\n\n  private _getObservers(node: estree.ClassDeclaration|estree.ClassExpression) {\n    const returnedValue = this._getReturnValueOfStaticGetter(node, 'observers');\n    if (returnedValue) {\n      return extractObservers(returnedValue, this._document);\n    }\n  }\n\n  private _getReturnValueOfStaticGetter(\n      node: estree.ClassDeclaration|estree.ClassExpression,\n      methodName: string): estree.Node|undefined {\n    const observedAttributesDefn: estree.MethodDefinition|undefined =\n        node.body.body.find((m) => {\n          if (m.type !== 'MethodDefinition' || !m.static) {\n            return false;\n          }\n          return astValue.getIdentifierName(m.key) === methodName;\n        });\n    if (observedAttributesDefn) {\n      const body = observedAttributesDefn.value.body.body[0];\n      if (body && body.type === 'ReturnStatement' && body.argument) {\n        return body.argument;\n      }\n    }\n    return;\n  }\n\n  /**\n   * Extract attributes from the array expression inside a static\n   * observedAttributes method.\n   *\n   * e.g.\n   *     static get observedAttributes() {\n   *       return [\n   *         /** @type {boolean} When given the element is totally inactive *\\/\n   *         'disabled',\n   *         /** @type {boolean} When given the element is expanded *\\/\n   *         'open'\n   *       ];\n   *     }\n   */\n  private _extractAttributesFromObservedAttributes(arry:\n                                                       estree.ArrayExpression) {\n    const results: ScannedAttribute[] = [];\n    for (const expr of arry.elements) {\n      const value = astValue.expressionToValue(expr);\n      if (value && typeof value === 'string') {\n        let description = '';\n        let type: string|null = null;\n        const comment = esutil.getAttachedComment(expr);\n        if (comment) {\n          const annotation = jsdoc.parseJsdoc(comment);\n          description = annotation.description || description;\n          const tags = annotation.tags || [];\n          for (const tag of tags) {\n            if (tag.tag === 'type') {\n              type = type || tag.type;\n            }\n            description = description || tag.description || '';\n          }\n        }\n        const attribute: ScannedAttribute = {\n          name: value,\n          description: description,\n          sourceRange: this._document.sourceRangeForNode(expr),\n          astNode: expr,\n          warnings: [],\n        };\n        if (type) {\n          attribute.type = type;\n        }\n        results.push(attribute);\n      }\n    }\n    return results;\n  }\n\n\n  /**\n   * Gets all found elements. Can only be called once.\n   */\n  getRegisteredElements(): ScannedElement[] {\n    for (const classAndTag of this._registeredButNotFound.entries()) {\n      const className = classAndTag[0];\n      const tagNameExpression = classAndTag[1];\n      const element = this._possibleElements.get(className);\n      if (element) {\n        element.className = className;\n        const tagNameResult = this.getTagNameFromExpression(tagNameExpression);\n        if (tagNameResult.successful) {\n          element.tagName = tagNameResult.value;\n        } else {\n          this._warnings.push(tagNameResult.value);\n        }\n        this._elements.add(element);\n      }\n    }\n    return Array.from(this._elements);\n  }\n\n  getTagNameFromExpression(expression: TagNameExpression):\n      Result<string|undefined, Warning> {\n    if (expression.type === 'string-literal') {\n      return {successful: true, value: expression.value};\n    }\n    const element = this._possibleElements.get(expression.className) ||\n        Array.from(this._elements)\n            .find((e) => e.className === expression.className);\n    if (!element) {\n      return {successful: false, value: {\n                code: 'cant-determine-element-tagname',\n                message:\n                    `Couldn't dereference the class name ${expression.className\n          } here.`,\n          severity: Severity.WARNING,\n          sourceRange: expression.classNameSourceRange\n        }\n      };\n    }\n    return {successful: true, value: element.tagName};\n  }\n\n  getTagNameExpression(expression: estree.Node):\n      Result<TagNameExpression, Warning> {\n    const tryForLiteralString = astValue.expressionToValue(expression);\n    if (tryForLiteralString != null &&\n        typeof tryForLiteralString === 'string') {\n      return {\n        successful: true,\n        value: {\n          type: 'string-literal',\n          value: tryForLiteralString,\n          sourceRange: this._document.sourceRangeForNode(expression)!\n        }\n      };\n    }\n    if (expression.type === 'MemberExpression') {\n      // Might be something like MyElement.is\n      const isPropertyNameIs = (expression.property.type === 'Identifier' &&\n                                expression.property.name === 'is') ||\n          (astValue.expressionToValue(expression.property) === 'is');\n      const className = astValue.getIdentifierName(expression.object);\n      if (isPropertyNameIs && className) {\n        return {\n          successful: true,\n          value: {\n            type: 'is',\n            className,\n            classNameSourceRange:\n                this._document.sourceRangeForNode(expression.object)!\n          }\n        };\n      }\n    }\n    return {\n      successful: false,\n      value: {\n        code: 'cant-determine-element-tagname',\n        message:\n            `Unable to evaluate this expression down to a definitive string ` +\n            `tagname.`,\n        severity: Severity.WARNING,\n        sourceRange: this._document.sourceRangeForNode(expression)!\n      }\n    };\n  }\n}\n"]}