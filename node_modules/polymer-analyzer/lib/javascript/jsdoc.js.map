{"version":3,"sources":["javascript/jsdoc.ts"],"names":[],"mappings":"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","file":"jsdoc.js","sourcesContent":["/**\n * @license\n * Copyright (c) 2015 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport * as doctrine from 'doctrine';\nimport * as estree from 'estree';\n\nimport {JavaScriptDocument} from '../javascript/javascript-document';\nimport {Privacy} from '../model/model';\nimport {ScannedReference, Severity, Warning} from '../model/model';\n\n/**\n * An annotated JSDoc block tag, all fields are optionally processed except for\n * the tag:\n *\n *     @TAG {TYPE} NAME DESC\n */\nexport interface Tag {\n  tag: string;\n  type: string|null;\n  name: string|null;\n  description: string|null;\n}\n\n/**\n * The parsed representation of a JSDoc comment.\n */\nexport interface Annotation {\n  // If no description is found, the property will be an empty string.\n  description: string;\n  tags: Tag[]|null;\n}\n\n/**\n * doctrine configuration,\n * CURRENTLY UNUSED BECAUSE PRIVATE\n */\n// function configureDoctrine() {\n\n//   // @hero [path/to/image]\n//   doctrine.Rules['hero'] = ['parseNamePathOptional', 'ensureEnd'];\n\n//   // // @demo [path/to/demo] [Demo title]\n//   doctrine.Rules['demo'] = ['parseNamePathOptional', 'parseDescription',\n//   'ensureEnd'];\n\n//   // // @polymerBehavior [Polymer.BehaviorName]\n//   doctrine.Rules['polymerBehavior'] = ['parseNamePathOptional', 'ensureEnd'];\n// }\n// configureDoctrine();\n\n// @demo [path] [title]\nfunction parseDemo(tag: doctrine.Tag): Tag {\n  const match = (tag.description || '').match(/^\\s*(\\S*)\\s*(.*)$/);\n  return {\n    tag: 'demo',\n    type: null,\n    name: match ? match[1] : null,\n    description: match ? match[2] : null\n  };\n}\n\n// @hero [path]\nfunction parseHero(tag: doctrine.Tag): Tag {\n  return {tag: tag.title, type: null, name: tag.description, description: null};\n}\n\n// @polymerElement\nfunction parsePolymerElement(tag: doctrine.Tag): Tag {\n  return {tag: tag.title, type: null, name: tag.description, description: null};\n}\n\n// @polymerMixin [name]\nfunction parsePolymerMixin(tag: doctrine.Tag): Tag {\n  return {tag: tag.title, type: null, name: tag.description, description: null};\n}\n\n// @polymerMixinClass [name]\nfunction parsePolymerMixinClass(tag: doctrine.Tag): Tag {\n  return {tag: tag.title, type: null, name: tag.description, description: null};\n}\n\n// @polymerBehavior [name]\nfunction parsePolymerBehavior(tag: doctrine.Tag): Tag {\n  return {tag: tag.title, type: null, name: tag.description, description: null};\n}\n\n// @pseudoElement name\nfunction parsePseudoElement(tag: doctrine.Tag): Tag {\n  return {tag: tag.title, type: null, name: tag.description, description: null};\n}\n\nconst CUSTOM_TAGS: {[name: string]: (tag: doctrine.Tag) => Tag} = {\n  demo: parseDemo,\n  hero: parseHero,\n  polymerBehavior: parsePolymerBehavior,\n  polymerElement: parsePolymerElement,\n  polymerMixin: parsePolymerMixin,\n  polymerMixinClass: parsePolymerMixinClass,\n  pseudoElement: parsePseudoElement,\n};\n\n/**\n * Convert doctrine tags to our tag format\n */\nfunction _tagsToHydroTags(tags: doctrine.Tag[]|null): Tag[]|null {\n  if (!tags)\n    return null;\n  return tags.map(function(tag): Tag {\n    if (tag.title in CUSTOM_TAGS) {\n      return CUSTOM_TAGS[tag.title](tag);\n    } else {\n      return {\n        tag: tag.title,\n        type: tag.type ? doctrine.type.stringify(tag.type) : null,\n        name: tag.name == null ? null : tag.name,\n        description: tag.description\n      };\n    }\n  });\n}\n\n/**\n * removes leading *, and any space before it\n */\nexport function removeLeadingAsterisks(description: string): string {\n  if ((typeof description) !== 'string')\n    return description;\n\n  return description.split('\\n')\n      .map(function(line) {\n        // remove leading '\\s*' from each line\n        const match = line.match(/^[\\s]*\\*\\s?(.*)$/);\n        return match ? match[1] : line;\n      })\n      .join('\\n');\n}\n\n/**\n * Given a JSDoc string (minus opening/closing comment delimiters), extract its\n * description and tags.\n */\nexport function parseJsdoc(docs: string): Annotation {\n  docs = removeLeadingAsterisks(docs);\n  const d = doctrine.parse(\n      docs, {unwrap: false, lineNumbers: true, preserveWhitespace: true});\n  // Strip any leading and trailing newline characters in the\n  // description of multiline comments for readibility.\n  // TODO(rictic): figure out if we can trim() here or not. Something something\n  //     markdown?\n  const description = d.description && d.description.replace(/^\\n+|\\n+$/g, '');\n  return {description: description, tags: _tagsToHydroTags(d.tags)};\n}\n\n// Utility\n\nexport function hasTag(\n    jsdoc: Annotation|null|undefined, tagName: string): boolean {\n  if (!jsdoc || !jsdoc.tags)\n    return false;\n  return jsdoc.tags.some(function(tag) {\n    return tag.tag === tagName;\n  });\n}\n\n/**\n * Finds the first JSDoc tag matching `name` and returns its value at `key`.\n *\n * If `key` is omitted, the entire tag object is returned.\n */\nexport function getTag(\n    jsdoc: Annotation|null|undefined, tagName: string): (Tag|null);\nexport function getTag(\n    jsdoc: Annotation|null|undefined, tagName: string, key: string): (string|\n                                                                      null);\nexport function getTag(\n    jsdoc: Annotation|null|undefined, tagName: string, key?: string): any {\n  if (!jsdoc || !jsdoc.tags)\n    return null;\n  for (let i = 0; i < jsdoc.tags.length; i++) {\n    const tag = jsdoc.tags[i];\n    if (tag.tag === tagName) {\n      return key ? tag[key] : tag;\n    }\n  }\n  return null;\n}\n\nexport function unindent(text: string): string {\n  if (!text)\n    return text;\n  const lines = text.replace(/\\t/g, '  ').split('\\n');\n  const indent = lines.reduce<number>(function(prev, line) {\n    if (/^\\s*$/.test(line))\n      return prev;  // Completely ignore blank lines.\n\n    const lineIndent = line.match(/^(\\s*)/)![0].length;\n    if (prev === null)\n      return lineIndent;\n    return lineIndent < prev ? lineIndent : prev;\n  }, 0);\n\n  return lines\n      .map(function(l) {\n        return l.substr(indent);\n      })\n      .join('\\n');\n}\n\nexport function isAnnotationEmpty(docs?: Annotation) {\n  if (!docs) {\n    return false;\n  }\n  const hasNoTags = !docs.tags || docs.tags.length === 0;\n  return docs.description.trim() === '' && hasNoTags;\n}\n\nfunction isPrivacy(maybePrivacy: string): maybePrivacy is Privacy {\n  switch (maybePrivacy) {\n    case 'public':\n    case 'private':\n    case 'protected':\n      return true;\n  }\n  return false;\n}\n\nexport function getPrivacy(jsdoc: Annotation|null|undefined): Privacy|null {\n  if (!jsdoc || !jsdoc.tags) {\n    return null;\n  }\n  for (const tag of jsdoc.tags) {\n    if (isPrivacy(tag.tag)) {\n      return tag.tag;\n    }\n  }\n  return null;\n}\n\nexport function getMixins(\n    document: JavaScriptDocument,\n    node: estree.Node,\n    docs: Annotation,\n    warnings: Warning[]) {\n  const mixesAnnotations = docs.tags!.filter((tag) => tag.tag === 'mixes');\n  return mixesAnnotations\n      .map((annotation) => {\n        const mixinId = annotation.name;\n        // TODO(justinfagnani): we need source ranges for jsdoc\n        // annotations\n        const sourceRange = document.sourceRangeForNode(node)!;\n        if (mixinId == null) {\n          warnings.push({\n            code: 'class-mixes-annotation-no-id',\n            message:\n                '@mixes annotation with no identifier. Usage `@mixes MixinName`',\n            severity: Severity.WARNING, sourceRange,\n          });\n          return;\n        }\n        return new ScannedReference(mixinId, sourceRange);\n      })\n      .filter((m) => m != null) as ScannedReference[];\n}\n"]}